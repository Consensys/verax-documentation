# Create an Attestation

After determining the Schema and potential Modules to use, and after the deployment and registration of your Portal, you can begin creating [Attestations](../../core-concepts/attestations.md).

## Attestation registration

Attestation registration at the Portal level takes 2 parameters, defined as follows:

<table><thead><tr><th width="190.54206896551727">Property</th><th>Description</th></tr></thead><tbody><tr><td>attestationPayload</td><td>The payload to attest</td></tr><tr><td>validationPayload</td><td>The payloads to validate via the modules to issue the attestation</td></tr></tbody></table>

`attestationPayload` is defined in Solidity as follows:

```solidity
struct AttestationPayload {
  bytes32 schemaId;
  uint64 expirationDate;
  bytes subject;
  bytes attestationData;
}
```

<table><thead><tr><th width="190.54206896551727">Property</th><th>Description</th></tr></thead><tbody><tr><td>schemaId</td><td>The identifier of the schema this attestation adheres to</td></tr><tr><td>expirationDate</td><td>The expiration date of the attestation</td></tr><tr><td>subject</td><td>The ID of the attestee, EVM address, DID, URL etc</td></tr><tr><td>attestationData</td><td>The attestation data</td></tr></tbody></table>

## Manually registering an Attestation in the `AttestationRegistry` contract

To register an Attestation into the `AttestationRegistry` contract, you need to go through the Portal you have previously deployed an registered, using the attest function:

```solidity
function attest(
  AttestationPayload memory attestationPayload,
  bytes[] memory validationPayload
) public payable;
```

When attesting, the registry performs a set of integrity checks on the new attestation:

* verifies the `schemaId` exists
* verifies the `subject` field is not blank
* verifies the `attestationData` field is not blank

## Using a blockchain explorer

Instead of drafting the csmart contract call by hand, you can benefit from a chai explorer interface. Let's use the Linea testnet explorer, [Lineascan](https://goerli.lineascan.build/).

<figure><img src="../../.gitbook/assets/Capture d’écran 2024-04-11 à 14.07.53.png" alt="" width="217"><figcaption><p>The form generated by Lineascan to interact with the <code>Portal</code> contract</p></figcaption></figure>

1. Retrieve the address of the `Portal` contract you previously deployed
2. Access the Portal contract on [Lineascan](https://goerli.lineascan.build/address/0x2fafe2c217be096e09b64c49825fe46b7c3e33b2)
3. Got to the ["Contract" tab](https://goerli.lineascan.build/address/0x2fafe2c217be096e09b64c49825fe46b7c3e33b2#code)
4. Got to the ["Write" tab](https://goerli.lineascan.build/address/0x2fafe2c217be096e09b64c49825fe46b7c3e33b2#writeContract)
5. Connect your wallet and fill the attest form with the parameters described above
6. Send the transaction

## Using the official Verax SDK

We have seen rather manual ways to create an Attestation, now let's focus on the easiest way: via the Verax SDK.

{% hint style="info" %}
Check this page to discover how to instantiate ethe Verax SDK.
{% endhint %}

Once you have an SDK instance, you can create an Attestation like this:

```typescript
await veraxSdk.portal.attest(
        "0x2fafe2c217be096e09b64c49825fe46b7c3e33b2",
        {
                schemaId: "0x9ba590dd7fbd5bd1a7d06cdcb4744e20a49b3520560575cd63de17734a408738",
                expirationDate: 1693583329,
                subject: "0x828c9f04D1a07E3b0aBE12A9F8238a3Ff7E57b47",
                attestationData: [{ isBuidler: true }],
        },
        []
);
```

## Attestation Metadata

When creating an attestation, you simply need to specify four properties, as outlined above, however, the attestation registry itself automatically populates the other fields in the attestation metadata at the point at which it is created. The full list of attestation metadata is included below:

<table><thead><tr><th width="180.54206896551727">Property</th><th width="114.33333333333331">Datatype</th><th>Description</th></tr></thead><tbody><tr><td>attestationId</td><td>bytes32</td><td>The unique identifier of the attestation</td></tr><tr><td>schemaId</td><td>bytes32</td><td>The identifier of the <a href="../../core-concepts/schemas.md">schema</a> this attestation adheres to</td></tr><tr><td>replacedBy</td><td>uint256</td><td>The attestation ID that replaces this attestation</td></tr><tr><td>attester</td><td>address</td><td>The address issuing the attestation to the subject</td></tr><tr><td>portal</td><td>address</td><td>The address of the <a href="../../core-concepts/portals.md">portal</a> that created the attestation</td></tr><tr><td>attestedDate</td><td>uint64</td><td>The date the attestation is issued</td></tr><tr><td>expirationDate</td><td>uint64</td><td>The expiration date of the attestation</td></tr><tr><td>revocationDate</td><td>uint64</td><td>The date when the attestation was revoked</td></tr><tr><td>version</td><td>uint16</td><td>Version of the registry when the attestation was created</td></tr><tr><td>revoked</td><td>bool</td><td>Whether the attestation is <a href="revoke-an-attestation.md">revoked</a> or not</td></tr><tr><td>revocationDate</td><td>uint64</td><td>If revoked, the date it was revoked / replaced</td></tr><tr><td>subject</td><td>bytes</td><td>The ID of the attestee e.g. an EVM address, DID, URL etc.</td></tr><tr><td>attestationData</td><td>bytes</td><td>The raw attestation data</td></tr></tbody></table>

The attestationId is derived from an internal auto-incremented counter, converted from uint32 to byte32. This corresponds to the total attestations issued. Moreover, the ID is prefixed with a chain identifier. This way, an attestation issued on Arbitrum cannot have t he same ID as an attestation issued on Linea, which is great in terms of cross-chain discovery!

Once the attestation is successfully created in the registry, an `AttestationRegistered` event is emitted with the attestation ID, and subsequently picked up by indexers.
